#!/usr/bin/python

"""
Provides the Pi input for the ProVerif tool for the TLS protocol as modeled in the AVISPA project.

Modeler: Pascal Lafourcade
"""

import commands
import tempfile

import Protocol

class avispa_tls_pi(Protocol.Protocol):

    def __init__(self):
        models = ["Traces"]
        claims = ["sAsk","sAck","sBsk","sBck"]
        name = "avispa_tls"
        Protocol.Protocol.__init__(self,name,"proverif",models,claims)

    def roleList(self):
        return ["a","b"]

    def roleCount(self):
        return len(self.rolelist())

    def generate(self,model="Traces",claim="sAsk",runs=0):
        prot = """
(* TLS *)

(*
 0. A -> B: A, Na, Sid, Pa	       	where Pa is a cryptosuite offer
 1. B -> A: Nb, Sid, Pb		where Pb is B's counteroffer
 2. B -> A: {B, Kb}inv(Ks)		optional certificate exchange
 3. A -> B: {A, Ka}inv(Ks)		optional certificate exchange
 4. A -> B: {PMS}Kb			where PMS is a nonce generated by A
 5. A -> B: {H(Nb,B,PMS)}inv(Ka)	optional certificate verify message
 6. A -> B: {Finished}Keygen(A, Na, Nb, M) 
 		where 	M = PRF(PMS,Na,Nb)
			Finished = H(M,messages) for all messages 0 - 5
 7. B -> A: {Finished}Keygen(B, Na, Nb, M)
*)

free c.

(* Hash function*)
fun hash/1.

(* PRF funciton *)
fun PRF/3.
  
(* Public key cryptography *)

fun pk/1.
private fun sk/1.
private fun sg/1.
(* just encryption, no signing *)
fun encrypt/2.
reduc decrypt(encrypt(x,pk(y)),sk(y)) = x.

(* sign *)

fun sign/2.

reduc unsign(sign(x,sg(y)),pk(y)) = x.

(* Symmetric key cryptography *)
fun symcrypt/2.
reduc symdecrypt(symcrypt(z,j),j) = z.

(* Keygen *)
fun keygen/4.

(* Effectively the claim signals *)
private free secretAck, secretAsk, secretBck, secretBsk.

(* Security claims to verify *)
        """
        qstr = claim[1:]
        prot += "query attacker:secret%s." % (qstr)

        prot += """

      let processA =
		(* read PA a cryptosuite offer *)
	        in(c , pa);
		(* Generate new nonce and session Id and send it*)
                new Na;
                new Sida;
		let M0 = (A, Na, Sida, pa ) in
		out(c, M0);
	
		in(c, M1 );
		let (nb,=Sida,pb) = M1 in

		(* Reception du certificat de B *)
                in(c, M2);
		let (b, pkb) = unsign(M2, pk(S)) in 

		let M3 =  sign((A,pk(A)),sg(S)) in
		out(c, M3);

                new Pms;
		let M4 = encrypt(Pms, pkb) in 
                out(c, M4);

		let M5 =  sign(hash((nb,b,Pms)),sk(A)) in
		out(c, M5);

		(* Keygen new key *)
		let M = PRF(Pms,Na,nb) in
		let finished =  hash( (M,M0,M1,M2,M3,M4,M5) ) in
		out(c, symcrypt(finished, keygen(A,Na,nb,M)));
	
	        in(c, m7 );

		let (=finished) = symdecrypt(m7, keygen(b,Na,nb,M)) in

		if b = A then
			out(c, symcrypt(secretAsk, keygen(b,Na,nb,M)));
			out(c, symcrypt(secretAck, keygen(A,Na,nb,M)))
			else	if b = B then
				out(c, symcrypt(secretAsk, keygen(b,Na,nb,M)));
				out(c, symcrypt(secretAck, keygen(A,Na,nb,M))).

	let processB =
	
		in(c, m0);
		let (a,na,sida,pa) = m0 in 
		(* read PB a cryptosuite offer *)
	
		(* Generate new nonce and pb couter offer of pa an send it*)
                new Nb;
                new Pb;
		let m1 = (Nb, sida, Pb) in
		out(c, m1); 
		(* Send certificate given by S *)
		let m2 = sign((B,pk(B)),sg(S)) in
		out(c, m2);
	      	
                in(c,  m3);
		let (=a,pka) = unsign(m3, pk(S)) in

		in(c,  m4);
		let (pms) = decrypt(m4, sk(B)) in
	
		in(c,  m5);
		let h1 = unsign(m5, pka) in
		let M = PRF(pms,na,Nb) in
 		if h1 = hash((Nb,B, pms)) then
	
			in(c,  m6);
			let finished = symcrypt(m3, keygen(a,na,Nb, M)) in

			if finished = hash((M,m0,m1,m2,m3,m4,m5)) then
				out(c, encrypt(finished, keygen(B, na, Nb, M)));
		
				if a = A then
				out(c, symcrypt(secretBsk, keygen(B,na,Nb,M)));
				out(c, symcrypt(secretBck, keygen(a,na,Nb,M)))
				else	if a = B then
					out(c, symcrypt(secretBsk, keygen(B,na,Nb,M)));
					out(c, symcrypt(secretBck, keygen(a,na,Nb,M))).


process
new A;
new I;
new B;
new PA;
new PB;
new PI;
new SIDI;
new S;

out(c, A);
out(c, I);
out(c, B);
out(c, S);
out(c, PA);
out(c, PB);
out(c, sk(I));
out(c, pk(S));
out(c, PI);
out(c, SIDI);

 ((!processA)| (!processB))

        """

        args = ""
        return (prot,args)


Protocol.register(avispa_tls_pi())

if __name__ == "__main__":
    x = avispa_tls_pi()
    (prot,args) =  x.generate("Traces")
    print prot
    print args

